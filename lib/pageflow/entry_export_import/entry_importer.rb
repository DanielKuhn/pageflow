module Pageflow
  module EntryExportImport
    # Creates an entry from JSON with latest draft and published revision including all used files.
    # The JSON structure must match the one generated by Pageflow::EntrySerializer.
    # A version check is performed for all plugins to assure data compatibility.
    # The newly created entry will be associated with the user passed into the initializer,
    # along with that users account and theming.
    class EntryImporter
      DEFAULT_REMOVAL_COLUMNS = %w[id state updated_at].freeze
      ENCODED_FILE_REMOVAL_COLUMNS = %w[encoding_progress encoding_error_message
                                        unpacking_progress unpacking_error_message].freeze

      def initialize(user, attachments_root_path)
        @user = user
        @account = @user.accounts.first
        @theming = @account.themings.first
        @attachments_root_path = attachments_root_path

        # file-mapping from exported to new id for nested files and source image files.
        @file_mapping = {}
      end

      def call(json_data)
        import_data = JSON.parse(json_data)

        page_type_version_requirements = import_data['page_type_version_requirements']
        unless data_compatible_for_import?(page_type_version_requirements)
          raise 'Incompatible Plugin versions detected'
        end

        entry_data = import_data['entry']
        draft_data = entry_data.delete('draft')
        published_revision_data = entry_data.delete('published_revision')

        Entry.transaction do
          @entry = create_entry(entry_data)
          create_revision(draft_data) if draft_data.present?
          create_revision(published_revision_data) if published_revision_data.present?
        end
      end

      private

      # Create an entry with given data after removing all host-specific information.
      def create_entry(data)
        entry_data = data.except(*DEFAULT_REMOVAL_COLUMNS)
        entry_data['account_id'] = @account.id
        entry_data['theming_id'] = @theming.id
        Pageflow::Entry.create!(entry_data.merge(skip_draft_creation: true))
      end

      def create_revision(data)
        revision_data = data.except(*DEFAULT_REMOVAL_COLUMNS)
        revision_data['creator_id'] = @user.id
        unless Pageflow.config.themes.map(&:name).include?(revision_data['theme_name'])
          revision_data['theme_name'] = 'default'
        end

        widgets_data = revision_data.delete('widgets')
        revision_components_data = revision_data.delete('serialized_components')
        storylines_data = revision_data.delete('storylines')
        file_usages_data = revision_data.delete('file_usages')

        # create revision
        revision = @entry.revisions.create!(revision_data)

        # create widgets
        widgets_data.each do |widget_data|
          revision.widgets.create!(widget_data.except(*DEFAULT_REMOVAL_COLUMNS))
        end

        # create revision components
        revision_components_data.each do |data|
          component_class_name = data.keys.first
          component_data = data[component_class_name].except(*DEFAULT_REMOVAL_COLUMNS)
          component_data['revision_id'] = revision.id
          component_class_name.constantize.create!(component_data) # page type concept?
        end

        # create storylines with chapters and pages
        storylines_data.each do |storyline_data|
          chapters_data = storyline_data.delete('chapters')
          storyline = revision.storylines.create!(storyline_data.except(*DEFAULT_REMOVAL_COLUMNS))
          chapters_data.each do |chapter_data|
            pages_data = chapter_data.delete('pages')
            chapter = storyline.chapters.create!(chapter_data.except(*DEFAULT_REMOVAL_COLUMNS))
            pages_data.each do |page_data|
              chapter.pages.create!(page_data.except(*DEFAULT_REMOVAL_COLUMNS))
            end
          end
        end

        # create files and usages
        create_files(file_usages_data, revision)
      end

      def create_files(file_usages_data, revision)
        # first pass: create files from usages
        create_files_for_revision(file_usages_data.deep_dup, revision)
        # second pass: link parent files
        link_parent_files(file_usages_data.deep_dup)
        # third pass: link source images
        link_source_images(file_usages_data)
      end

      def create_files_for_revision(file_usages_data, revision)
        file_usages_data.each do |file_usage_data|
          file_model = file_usage_data['file_type'].constantize
          file_type = Pageflow.config.file_types.find_by_model!(file_model)
          perma_id = file_usage_data['file_perma_id']

          file_data = file_usage_data.delete('file')
          exported_file_id = file_data.delete('id')

          # prepare data for file creation
          file_data = file_data.except(*(DEFAULT_REMOVAL_COLUMNS + ENCODED_FILE_REMOVAL_COLUMNS))
          file_data['uploader_id'] = @user.id if file_data['uploader_id'].present?
          file_data['confirmed_by_id'] = @user.id if file_data['confirmed_by_id'].present?
          file_data['entry_id'] = @entry.id # required for nested_file validation

          # specify attachment files directory
          local_files_directory = File.join(@attachments_root_path,
                                            file_type.collection_name,
                                            perma_id.to_s)

          importer = file_type.importer.new(local_files_directory)
          file = importer.call(file_type, file_data)

          # overwrite file id with new id (lookup is done by perma_id which stays unchanged)
          file_usage_data['file_id'] = file.id
          revision.file_usages.create!(file_usage_data.except(*DEFAULT_REMOVAL_COLUMNS))

          # map file by type from old to new id for linking parent files in second pass
          file_type_key = file_type.collection_name
          @file_mapping[file_type_key] ||= {}
          @file_mapping[file_type_key][exported_file_id] = file.id
        end
      end

      def link_parent_files(file_usages_data)
        file_usages_data.each do |file_usage_data|
          file_data = file_usage_data['file']
          next unless file_data['parent_file_id'].present?

          parent_file = find_file_by_exported_id(file_data['parent_file_model_type'],
                                                 file_data['parent_file_id'])

          nested_file = find_file_by_exported_id(file_usage_data['file_type'],
                                                 file_usage_data['file_id'])

          nested_file.update!(parent_file: parent_file)
        end
      end

      def link_source_images(file_usages_data)
        file_usages_data.each do |file_usage_data|
          file_data = file_usage_data['file']
          next unless file_data['source_image_file_id'].present?

          linkable_file = find_file_by_exported_id(file_usage_data['file_type'],
                                                   file_usage_data['file_id'])

          source_image_exported_id = file_data['source_image_file_id']
          source_image_new_id = @file_mapping['image_files'][source_image_exported_id]

          linkable_file.update!(source_image_file_id: source_image_new_id)
        end
      end

      def find_file_by_exported_id(model_name, exported_id)
        file_model = model_name.constantize
        file_type = Pageflow.config.file_types.find_by_model!(file_model)
        file_type_collection_name = file_type.collection_name
        new_id = @file_mapping[file_type_collection_name][exported_id]
        file_type.model.find(new_id)
      end

      def data_compatible_for_import?(page_type_version_requirements)
        page_type_version_requirements.each do |plugin_name, plugin_version_requirement|
          page_type = Pageflow.config.page_types.find_by_name!(plugin_name)
          current_version = Gem::Version.new(page_type.version)
          return false unless Gem::Requirement.new(plugin_version_requirement)
                                .satisfied_by?(current_version)
        end
        true
      end
    end
  end
end
